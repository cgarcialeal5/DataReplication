<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Cristina Garcia Leal">

<title>Data Replication Project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Data-Replication_files/libs/clipboard/clipboard.min.js"></script>
<script src="Data-Replication_files/libs/quarto-html/quarto.js"></script>
<script src="Data-Replication_files/libs/quarto-html/popper.min.js"></script>
<script src="Data-Replication_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Data-Replication_files/libs/quarto-html/anchor.min.js"></script>
<link href="Data-Replication_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Data-Replication_files/libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Data-Replication_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Data-Replication_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Data-Replication_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#citation" id="toc-citation" class="nav-link active" data-scroll-target="#citation">Citation:</a></li>
  <li><a href="#the-original-study" id="toc-the-original-study" class="nav-link" data-scroll-target="#the-original-study">The Original Study:</a>
  <ul class="collapse">
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods:</a></li>
  <li><a href="#data-used" id="toc-data-used" class="nav-link" data-scroll-target="#data-used">Data Used:</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results:</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions:</a></li>
  </ul></li>
  <li><a href="#the-reproduction" id="toc-the-reproduction" class="nav-link" data-scroll-target="#the-reproduction">The Reproduction:</a>
  <ul class="collapse">
  <li><a href="#before-we-start" id="toc-before-we-start" class="nav-link" data-scroll-target="#before-we-start">Before We Start:</a>
  <ul class="collapse">
  <li><a href="#packages" id="toc-packages" class="nav-link" data-scroll-target="#packages">Packages:</a></li>
  <li><a href="#reading-the-data" id="toc-reading-the-data" class="nav-link" data-scroll-target="#reading-the-data">Reading the data:</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Data Replication Project</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Cristina Garcia Leal </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="citation" class="level1">
<h1>Citation:</h1>
<p>Ashley E. Sharpe, Juan Manuel Palomo, Takeshi Inomata, Daniela Triadan, Flory Pinz√≥n, Jason Curtis, Kitty Emery, George Kamenov, John Krigbaum, Jessica MacLellan, Mar√≠a Paula Weihm√ºller, <em>An isotopic examination of Maya Preclassic and Classic animal and human diets at Ceibal, Guatemala,</em> Journal of Archaeological Science: Reports, Volume 55, 2024, 104522, ISSN 2352-409X, <a href="https://doi.org/10.1016/j.jasrep.2024.104522." class="uri">https://doi.org/10.1016/j.jasrep.2024.104522.</a></p>
</section>
<section id="the-original-study" class="level1">
<h1>The Original Study:</h1>
<p>This article attempts to answer a question that has plagued Maya archaeologists ever since they first understood the magnitude of these ancient civilizations: How did the Maya sustain their cities through time and fluctuations in the population? The authors emphasize that there was no ‚Äúuniversal‚Äù Maya diet, and as such, there was a lot of variation in dietary patterns across sites and across time. Thus, they argue, Ceibal is an ideal site to examine diet and subsistence through time because it had a long occupation that spanned from 1100 BC to 1200 CE. Ceibal was a significant political and ceremonial Maya center that experienced significant changes during its long occupation, including periods of abandonment and reoccupation.</p>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods:</h2>
<p>To examine this, the authors aimed to understand the relationship between animals and humans, hoping to trace shifts in diet and animal management. Their methods involved using isotope analysis to get information about the samples. The study measured carbon, oxygen, and strontium isotope in dental enamel. Carbon (ùõÖC<sup>13</sup>) was used to trace maize consumption by determining the proportion of C4 plants in the diet, oxygen (ùõÖO<sup>18</sup>) was used to trace drinking water sources and estimate mobility, and strontium (Sr<sup>87</sup>/Sr<sup>86</sup>) was used to trace geographic origins based on regional geology. All three isotopes were measured for faunal samples, however only carbon isotopes were measured for the human samples.</p>
<p>The measured isotope values for animals and humans were then analyzed statistically. The authors present descriptive statistics of the dog and deer isotope values for carbon, oxygen and strontium organized by chronological order. The distribution of values for each isotope was also analyzed statistically for each animal. Student‚Äôs t-tests were employed on the carbon values for dogs and humans for each time period to compare the difference in diets over time.</p>
</section>
<section id="data-used" class="level2">
<h2 class="anchored" data-anchor-id="data-used">Data Used:</h2>
<p>The fauna data contained 63 samples from non-human mammals excavated in Ceibal. The samples were excavated from different archaeological contexts and represented various different time periods, from the Early Middle Preclassic (1000-700 BCE) all the way to the Terminal Classic (810-950 CE). These samples came from various different types of teeth (molars, premolars, canines, and incisors). These faunal samples came from the following animals:</p>
<ol type="1">
<li>Domestic dog (<em>Canis lupus familiaris</em>): 45 samples</li>
<li>White-tailed deer (<em>Odocoileus virginianus</em>): 7 samples</li>
<li>Peccary (<em>Tayassuidae cf.&nbsp;Dicotyles tajacu</em>): 2 samples</li>
<li>Baird‚Äôs tapir (<em>Tapirella bairdii</em>): 3 samples</li>
<li>Large feline (possibly <em>Panthera onca</em>): 2 sample</li>
<li>Margay (<em>Leopardus wiedii</em>): 1 sample</li>
<li>Agouti (<em>Dasyprocta punctata</em>): 1 sample</li>
<li>Paca (<em>Cuniculus paca</em>): 1 sample</li>
<li>Opossum (<em>Philander opossum</em>): 1 sample</li>
</ol>
<p>The human data contained 21 samples from third molars and also represented individuals from different time periods. However, this sample only ranged from the Early Middle Preclassic to the Late Classic, there are no individuals from the Terminal Classic.</p>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results:</h2>
<p>The strontium measurements in the faunal sample suggest that dogs were the most mobile species and indicate that a large portion of the dogs came from regions south and west of Ceibal. The authors highlight one specific dog, whose strontium values match the volcanic highlands, which supports evidence that dogs were transported over long distances. Furthermore, oxygen values for dogs match Ceibal‚Äôs water sources, pointing to domestication. On the other hand, strontium and oxygen values for deer are both consistent with local and regional sources. Interestingly, the strontium values of the peccary and agouti also suggest non-local origins, which could be the result of either hunting zones or trade networks.</p>
<p>The carbon isotope results were also quite interesting. Dogs generally had higher values for carbon isotopes than humans, which indicates that dogs were eating more maize than humans were. Carbon results for deer were as expected, low values of ùõÖC<sup>13</sup> are consistent with a diet based on forest plants (C3 plants). Contrary to this, one large feline had higher ùõÖC<sup>13</sup> values than expected. Considering that these animals are carnivores, the elevated carbon values are evidence of higher maize consumption and could indicate that this animal was in captivity. The moderate values for the peccary and agouti imply that these animals consumed at least some maize. Lastly, carbon values for the human sample showed a clear increase of maize consumption through time, especially during the transition between the Preclassic and Classic periods.</p>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions:</h2>
<p>When these results were compared across time periods and compared to human consumption of maize (as evidenced by the carbon values of the human sample), several conclusions can be reached. First of all, the strontium and oxygen values indicate that deer were local and their carbon values do not point towards domestication. Thus, the authors conclude that they were probably locally hunted.</p>
<p>Carbon values for dogs suggest that they were fed maize from the Preclassic period and their dependence on maize increased heavily towards the Late Preclassic Period. However, variability during the Late Preclassic Period suggests that there were various methods of providing feed to domesticated dogs. During this period human consumption of maize is variable. The authors argue that during this time, dogs were being consumed as meat sources.</p>
<p>The variability decreases during the Classic Period, as uniform high values among all dogs indicate full dependence on maize. The same trend is observed in humans as they become more dependent on maize as well. The authors suggest that this is because dogs were no longer consumed as food, but kept as companions.</p>
</section>
</section>
<section id="the-reproduction" class="level1">
<h1>The Reproduction:</h1>
<p>For this project, I will be replicating three different types of analysis. First, I will recreate the visualization depicted in Figure 3 of the article, which shows the strontium values on the x-axis and the oxygen values on the y-axis. The figure has different colors representing the different types of animals and different symbols representing the different time periods. Then, I will replicate the descriptive statistics presented in Table 3 of the article. These statistics will be calculated for all three isotope values for dogs and deer divided by time period. Lastly, I will perform Student‚Äôs t-tests to compare carbon values for dogs and humans across time periods.</p>
<p>However, before starting any of the analysis I will clean up the data. When the data was downloaded from the supplementary information provided with the article, the information was saved in an excel document that contained two sheets. The first sheet contained the data from the fauna sample and the second sheet contained the data from the human sample. The first step to this project was separating this excel document into two documents (one for each table), cleaning up the tables in order for R to read the data, and saving the excel documents as .csv files. As such, the folder called ‚ÄúData‚Äù within this repository should have the following files:</p>
<ol type="1">
<li>OriginalData.xlsx : The original excel workbook from the supplementary information.</li>
<li>Table1_Fauna.xlsx: Excel workbook with data from faunal sample.</li>
<li>Table1_Fauna.csv: Same as above, but saved as a comma separated values file.</li>
<li>Table2_Human.xlsx: Excel workbook with data from human sample.</li>
<li>Table2_Human.csv: Same as above, but saved as a comma separated values file.</li>
</ol>
<section id="before-we-start" class="level2">
<h2 class="anchored" data-anchor-id="before-we-start">Before We Start:</h2>
<p>Before any analysis begins, I will prepare RStudio for the analysis by loading the packages needed for all analyses. I will also add packages here as I use them further on to facilitate the process for those replicating this document later. All files will be read by using the read_csv() function.</p>
<section id="packages" class="level3">
<h3 class="anchored" data-anchor-id="packages">Packages:</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>‚îÄ‚îÄ Attaching core tidyverse packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 2.0.0 ‚îÄ‚îÄ
‚úî dplyr     1.1.4     ‚úî readr     2.1.5
‚úî forcats   1.0.0     ‚úî stringr   1.5.1
‚úî ggplot2   3.5.1     ‚úî tibble    3.2.1
‚úî lubridate 1.9.4     ‚úî tidyr     1.3.1
‚úî purrr     1.0.2     
‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ
‚úñ dplyr::filter() masks stats::filter()
‚úñ dplyr::lag()    masks stats::lag()
‚Ñπ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'patchwork' was built under R version 4.4.3</code></pre>
</div>
</div>
</section>
<section id="reading-the-data" class="level3">
<h3 class="anchored" data-anchor-id="reading-the-data">Reading the data:</h3>
<section id="fauna-data" class="level4">
<h4 class="anchored" data-anchor-id="fauna-data">Fauna Data</h4>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="st">""</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>